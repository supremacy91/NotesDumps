cat /proc/cpuinfo - информация о процессорах системы
ctrl + D - возможно выходит из режима набора в консоли Ubuntu

sudo dpkg --configure -a - дебажит багнутый процесс установки

pkexec chmod 440 /etc/sudoers.d/README
pkexec chmod 755 /etc/sudoers.d

systemctl status apache2.service

sudo su - меняет пользователя на root
если стоит $ в командной строке Linux - то мы под обычным пользователем. 
если стоит # в командной строке Linux - то мы под root

sudo vipw - выводит список пользователей 
sudo users - показывает текущего пользователя

git status - статус на данный момент
git log - выводит историю коммитов
git log -p - в логе коммитов будут указаны изменения
git clean -d -f -удаляет все untracked файлы и директории
git branch -d name Удаляет ветку name
git checkout -b name создает и прыгает на ветку name
git merge name сливает текущую ветку с веткой name
  - Например на ветке b1 команда git merge b2: Если на b1 есть сознанные непроиндексированные файлы или созданные индексирвоанные файлы, которых нет на b2 - то придется их или закоммитить или удалить.   Если закоммитить - то мердж будет и после мерджа придется разрешить конфликт. И будет дерево логов с ветки b2, потом наш лог, потом лог мерджа. 

структура мерджа:
<<<<<<< HEAD
То что в текущей ветке
=======
То что в ветке, с которой мерджим
>>>>>>> код последнего коммита ветки, с которой мерджим 
Например:
<<<<<<< HEAD
LLLLLLLLLLLLLLLLL
=======
444444444444444444444
>>>>>>> b272fdbddb198ebf474260252d0097c4a47c6f19

git pull <remote_repository> <branch> 
Затягивает состояние удаленного репозитория и сливает его с текущим состоянием, выполняя merge.
Если коммиты текущего состояния включают состояние удаленго репозитория по коммитам - то текущее состояние не меняется.


git fetch - берет изменения с удаленного репозитория, н оне сливает их с текущим коммитом (git pull = git fetch + git merge)
git fetch тянет изменения по всем веткам и перейдя на другую ветку - мы можем сразу писать git merge - и смерджатся изменения с соответсвующей ветки удаленного репозитория.
    Обновляем локальное репо с удаленного устройства (но не обьединяем):
    git fetch

    После загрузки обновлений см. различия:
    git diff master origin/master

    Если довольны этими обновлениями, сливаем:
    git merge (либо git pull)


git push origin branch_name - заливает на удаленный репозиторий содержимое ветки branch_name. Если на удаленном репозитории нет еще ни одной ветки, 
	то branch_name будет главнео веткой и будет склонирована при использовании команды clone.
	Если мы выполняем эту команду, находясь на другйо веетке  - то все равно запушится branch_name в удаленно созданную branch_name
git push -f origin branch_name - заменяет содержимое удаленного репозитория текущей веткой branch_name.

git pull - origin branch_name - тянет и мерджит состояние удаленной ветки branch_name в текущую ветку, даже если текущая ветка не называется branch_name
	Если состояние коммитов текущей ветки и удаленной ветки branch_name отличаются, то к состоянию текущей ветки накинутся комминты удаленной ветки, 
	потом коммиты текущей ветки, которых нету в удаленной, а потом merge-коммит

git branch name создает ветку name
git branch name origin/master1 создает ветку name и загружает в нее ветку master1 по ссылке origin
git remote Чтобы просмотреть, какие удалённые серверы уже настроены
git remote -v Чтобы посмотреть, какому URL соответствует сокращённое имя в Git
git remote rename name1 name2 переименовует ссылку
git remote rm name удаляет ссылку
git remote rm origin удаляет ссылку на репозиторий
git remote add origin https://github.com/supremacy91/testnext.git - добавляет удаленный сервер
git diff  непроиндексированные изменения относительно последней индексации или коммита
git diff --cached проиндексированные изменения оттносительно последнего коммита
git checkout <имя файла>/. отменяет не проинедксированные изменения в файле/во всех файлах, но толкьо в том случае, если файлы находятся под версионным контролем (не untracked)
git revert f95324e7ee0ca7c6b - отменяет изменения, внесенные коммитом с хешкдом f95324e7ee0ca7c6b(просто пример возможного хешкода). В результате работы команды появится новый коммит, HEAD 		которого будет иметь состояние текущего HEAD, откатив те изменения, которые были закомиченны в коммите f95324e7ee0ca7c6b. Для выполнения команды локальные изменения должны быть закомиченны либо 	  стэшнуты
git commit --amend заменяет последний коммит. У коммита будет другой хешкод.
git reset код_коммита - перемещает HEAD на соответсвующий коммит в ветке. Можно так передвигать HEAD по обоим направлениям. 
git reset HEAD - и есть вызов команды выше. Кодом коммита будет код последнего коммита в текущей ветке, которым и есть псевдоним HEAD
git reset filename - записывает состояние подготовленных данных состоянием, на которое указывает HEAD. то есть отменяет индексацию файла относительно рабочего каталога.
git reset --soft код_коммита - меняет только значнеие HEAD на указанный коммит. То есть даныне раочего каталога останутся нетронутыми и проиндексированными в нетронутом состоянии. То есть зелененькими.
git reset --soft HEAD^ - тоже самое что выше, только берется код коммита-1 
git reset --soft HEAD~number - тоже самое что выше, только берется код коммита-number 
git reset --mixed код_коммита - меняет значнеие HEAD на указанный коммит делает по нему индексацию. Рабочий каталог оставляет нетронутым. То есть файлы будут светиться красненьким.
git reset --mixed HEAD^ - тоже самое что выше, только берется код коммита-1 
git reset --mixed HEAD~number - тоже самое что выше, только берется код коммита-number 
git reset --hard код_коммита меняет значнеие HEAD на указанный коммит делает по нему индексацию. Также меняет состояние рабоего каталога на новый HEAD. Единственный случай, когда можно потерять данные, если не сделали перед этой командой коммит.
git reset --hard HEAD^ - тоже самое что выше, только берется код коммита-1 
git reset --hard HEAD~number - тоже самое что выше, только берется код коммита-number 
-Если мы делаем git reset --hard HEAD^ или git reset --soft HEAD^ и в иерархии гитлога встречается мердж веток, то при команде резета будет прыжок до той ветки, от которой шли изменения, вызвавшие мердж. 

git rm name удаляет файл с директоии.  
- Если файл входит в текущий коммит, то это тоже самое, что и прсото физическое удаление файла с последующей командой git add(удаляет файл, н оне удаляет гит-индекс этог офайла. Посе этой команды будет зеленым светиться удаленный файл как deleted)
-Если файл был изменен и проиндексирован, то эта команда сработает только с спецификатором -f и удалит файл физически и с индекса и добавит команду git add, что в результате приведет к "чистоте" - файла не будет видно физически, ни в deleted ни в untracked)
-Если файл имеет проиндексированные изменения - то его можно удалять только форсировано (git rm -f  file_name)

git rm --cached name удаляет файл с индекса 
-Если файл входит в текущий коммит, то он будет светиться зеленым как deleted, а также красным как untracked - поскольку физически останется.
-Если файл проиндексирован как new file, то эта команда просто уберет его с индекса, отправив в untracked
-Если файл имеет проиндексированные изменения - то его можно удалять с индекса только форсировано (git rm -f --cached file_name)

git checkout branch
попросит закоммитить или откатить красные либо зеленые изменения, если они относятся к файлу, который есть в коммите. 
также попросить сделать тоже самое с файлом, который есть в коммите ветки на которую прыгаем.

git checkout -f branch
git checkout --force branch
прыгают наветку решая проблемы откатом индекса и рабочего каталога до состояния хеда

Последовательность команд, если надо удалить untracked файлы:
git add .
git rm -r -f .
git reset HEAD
git checkout .


git push origin master - заливает в репозиторий

в PHPSTORM: пкм(где угодно в открытом проекте) -> Git -> Resolve Conflicts...

which phpstorm(или другйо исполняемый файл) - выдает полный путь к Шторму или другомй исполняемому файлу

sudo rm -R -d name -удаляет рекурсивно директорию с файлами
sudo rm -R -d name/* -удаляет рекурсивно файлы с директории

rm file - удалить файл
rm -R dir - удалить каталог
rm -rf dir/* - удаляет всe рекурсивно из папки dir
rm -rd dir/* - удаляет всe пустые папки b файлы из папки dir 
rm -d dir/* - удаляет всe пустые папки b файлы из папки dir 

cat file1 > file2 - копирует содержимое первого файла во второй. Если второго файла нет создает его.
cat > file2 - редактирует файл, запрашивая ввод содержимого с клавиатуры. Вводим содержимое и нажимаем Ctrl+D/Ctrl+C. Если файла нет - создает его

cp file1 file2 копирует содержимое первого файла во второй. Если второго файла нет создает его.

http://www.linuxcenter.ru/lib/books/kostromin/gl_04_06.phtml - крутой гайд по командам

Ключ -v покажет "комментарий", т.е. выведет на экран подтверждение действий 
например: rm -vR dir - удалить каталог 
---------------------------------------------------------------------------------------------------------------------

mv file newfile - меняет имя файла file на newfile
mkdir ~/My_directory_name - создаст директорию My_directory_name в каталоге home
mkdir /My_directory_name - создаст директорию My_directory_name в каталоге Computer

создание файлов
touch "filename" -------создать пустой файл
cat > "filename" --------и ввод закончить ctrl+z
vim "filename" --------создать или редактировать "filename" 
nano filename
echo "текст" > filename

wget - закачивает файлы с сайта по его адресу. Если сайт на https - то тоже закачиввает 
scp - можно закачать любой файл по ssh, зная его директорию на сервере (например: scp user@domain:path_to_the_file)

sudo gedit file - можно открыть file удобным редактором, если на него ограниченны права

---------------------------------------------------------------------------------------------------------------------

При работе с vim:

    :q - quit if no changes were made
    :q! - quit and destroy any changes made
    :wq - write changes (save) and quit
    :x - similar to :wq, only write the file if changes were made, then quit

предварительно нажать esc перед вводом команд

---------------------------------------------------------------------------------------------------------------------

редактор mc
sudo apt-get install mc

mc - запустить редактор mc вместо текущей консоли
mcedit file_name - открыть файл на реактирование через mc

-----------------------------------------------------------------------------------------------------------------------

ssh ключи

ssh ключи хранятся в директории
/home/username/.ssh/

для генерации ключей команда:
ssh-keygen
по умолчанию предложит создать ключ в директорию
/home/maks/.ssh/id_rsa
в итоге создаст публичный и скрытый ключи:
/home/maks/.ssh/id_rsa	   - скрытый ключ, например используется для ssh://github... или ssh://bitbucket... 
/home/maks/.ssh/id_rsa.pub - публичный ключ

/home/maks/.ssh/ - это директория, где будут искаться ключи в случае, если ничего не задано в файле config

/home/maks/.ssh/config - тут задаем директории поиска ключа для хостов.
Например, для битбакета:
    Host bitbucket.org
    HostName bitbucket.org
    User supremacy_91
    IdentityFile ~/.ssh/projects/bitbucket/key

Учитывая конфиг выше, ключи для битбакета создаем:
maks@maksPC:~/.ssh/projects/bitbucket$ ssh-keygen


-----------------------------------------------------------------------------------------------------------------------

поменять конфигурацию гита:

.git/config
[core]
        repositoryformatversion = 0
        filemode = false 			// если включен, то изменения прав на файлы будут воспрниматься гитом как измененеия
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = https://Q_Developer@bitbucket.org/firstaidenbitbossnl/calexis.git
        fetch = +refs/heads/*:refs/remotes/origin/*
[user]
        email = dev24.magento@intechsoft.net
        name = IntechSoft
[branch "release_4"]
        remote = origin


-----------------------------------------------------------------------------------------------------------------------

Roger Shah and Signum – Healesville Sanctuary
